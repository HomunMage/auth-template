# OAuth 2.0 Authentication Tutorial

A practical guide to implementing OAuth 2.0 with PKCE using SvelteKit and FastAPI.

## Table of Contents

- [What is OAuth 2.0?](#what-is-oauth-20)
- [Key Concepts](#key-concepts)
- [PKCE Flow Explained](#pkce-flow-explained)
- [Public vs Confidential Clients](#public-vs-confidential-clients)
- [Implementation Guide](#implementation-guide)
- [Project Structure](#project-structure)
- [Setup](#setup)

---

## What is OAuth 2.0?

OAuth 2.0 is an authorization framework that allows third-party applications to access user resources without exposing credentials. Instead of sharing passwords, users authorize apps to act on their behalf.

**Example:** When you click "Login with Google", you're redirected to Google's login page. After authenticating, Google asks if you want to grant the app access to your profile. If you agree, Google sends back a token the app can use.

---

## Key Concepts

### Authorization Server
The service that authenticates users and issues tokens (e.g., Google, Authentik).

### Resource Server
The API that holds protected resources (e.g., Google's user profile API).

### Client
Your application requesting access to user resources.

### Tokens

| Token | Purpose | Lifetime |
|-------|---------|----------|
| **Access Token** | Authorizes API requests | Short (minutes to hours) |
| **Refresh Token** | Obtains new access tokens | Long (days to months) |
| **ID Token** | Contains user identity info (OpenID Connect) | Short |

### Scopes
Permissions requested by the client. Examples:
- `openid` - Required for OpenID Connect
- `profile` - User's name, picture
- `email` - User's email address

---

## PKCE Flow Explained

**PKCE** (Proof Key for Code Exchange) prevents authorization code interception attacks. It's required for public clients and recommended for all OAuth flows.

### Step-by-Step Flow

```
┌──────────┐                              ┌─────────────────┐
│  Browser │                              │ Auth Server     │
│ (Client) │                              │ (Google/etc)    │
└────┬─────┘                              └────────┬────────┘
     │                                             │
     │ 1. Generate code_verifier (random string)   │
     │ 2. Create code_challenge = SHA256(verifier) │
     │                                             │
     │ 3. Redirect to /authorize ─────────────────>│
     │    ?response_type=code                      │
     │    &client_id=xxx                           │
     │    &redirect_uri=http://localhost/callback  │
     │    &scope=openid profile email              │
     │    &state=random123                         │
     │    &code_challenge=abc123                   │
     │    &code_challenge_method=S256              │
     │                                             │
     │                         User logs in & consents
     │                                             │
     │ 4. Redirect to callback <───────────────────│
     │    ?code=AUTH_CODE&state=random123          │
     │                                             │
     │ 5. POST /token ────────────────────────────>│
     │    grant_type=authorization_code            │
     │    &code=AUTH_CODE                          │
     │    &redirect_uri=http://localhost/callback  │
     │    &client_id=xxx                           │
     │    &code_verifier=original_verifier  ←──────── Proves we initiated the request
     │                                             │
     │ 6. Receive tokens <─────────────────────────│
     │    { access_token, refresh_token, id_token }│
     │                                             │
```

### Why PKCE Works

1. **code_verifier**: Random string generated by client (kept secret)
2. **code_challenge**: Hash of verifier sent in authorization request
3. **Verification**: Token endpoint requires original verifier that hashes to the challenge

An attacker who intercepts the authorization code cannot exchange it without the original verifier.

---

## Public vs Confidential Clients

### Public Client (Authentik example)
- Cannot securely store secrets (browser apps, mobile apps)
- Uses PKCE for security
- Token exchange happens directly in browser

```typescript
// Frontend exchanges code directly
const tokens = await fetch(tokenUrl, {
  method: 'POST',
  body: new URLSearchParams({
    grant_type: 'authorization_code',
    code: authCode,
    client_id: 'xxx',
    code_verifier: verifier,  // PKCE proof
    redirect_uri: 'http://localhost/callback'
  })
});
```

### Confidential Client (Google example)
- Can securely store secrets (backend servers)
- Uses client_secret + PKCE for extra security
- Token exchange happens on backend

```python
# Backend exchanges code with secret
response = requests.post(token_url, data={
    'grant_type': 'authorization_code',
    'code': auth_code,
    'client_id': 'xxx',
    'client_secret': 'SECRET',  # Only backend knows this
    'code_verifier': verifier,
    'redirect_uri': 'http://localhost/callback'
})
```

---

## Implementation Guide

### 1. PKCE Utilities (`frontend/src/lib/auth/pkce.ts`)

```typescript
// Generate random string for code_verifier
export function generateRandomString(length: number): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  return Array.from(crypto.getRandomValues(new Uint8Array(length)))
    .map((x) => chars[x % chars.length])
    .join('');
}

// Create code_challenge from verifier using SHA-256
export async function generateCodeChallenge(verifier: string): Promise<string> {
  const data = new TextEncoder().encode(verifier);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return btoa(String.fromCharCode(...new Uint8Array(hash)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}
```

### 2. Start Login (`frontend/src/lib/auth/auth.service.ts`)

```typescript
export async function startLogin(providerName: AuthProvider) {
  const provider = providers[providerName];

  // Generate PKCE values
  const codeVerifier = generateRandomString(128);
  const codeChallenge = await generateCodeChallenge(codeVerifier);
  const state = generateRandomString(32);

  // Store for callback verification
  sessionStorage.setItem(`pkce_${providerName}`, codeVerifier);
  sessionStorage.setItem(`state_${providerName}`, state);

  // Build authorization URL
  const params = new URLSearchParams({
    response_type: 'code',
    client_id: provider.clientId,
    redirect_uri: provider.redirectUri,
    scope: provider.scope,
    state,
    code_challenge: codeChallenge,
    code_challenge_method: 'S256'
  });

  // Redirect to authorization server
  window.location.href = `${provider.authorizeUrl}?${params}`;
}
```

### 3. Handle Callback

```typescript
export async function handleOAuthCallback(
  providerName: AuthProvider,
  code: string,
  state: string
): Promise<LoginInfo> {
  // Verify state to prevent CSRF
  const savedState = sessionStorage.getItem(`state_${providerName}`);
  const verifier = sessionStorage.getItem(`pkce_${providerName}`);

  if (!verifier || state !== savedState) {
    throw new Error('Invalid OAuth state');
  }

  // Exchange code for tokens (method depends on client type)
  // ... see full implementation in source
}
```

### 4. Provider Configuration

```typescript
// Public client (Authentik)
export const authentikProvider: OAuthProviderConfig = {
  name: 'authentik',
  authorizeUrl: `${AUTHENTIK_URL}/application/o/authorize/`,
  tokenUrl: `${AUTHENTIK_URL}/application/o/token/`,
  userInfoUrl: `${AUTHENTIK_URL}/application/o/userinfo/`,
  clientId: 'your-client-id',
  redirectUri: 'http://localhost:3000/callback/authentik',
  scope: 'openid profile email'
};

// Confidential client (Google)
export const googleProvider: OAuthProviderConfig = {
  name: 'google',
  authorizeUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
  tokenUrl: 'https://oauth2.googleapis.com/token',
  userInfoUrl: 'https://www.googleapis.com/oauth2/v3/userinfo',
  clientId: 'your-client-id',
  redirectUri: 'http://localhost:3000/callback/google',
  scope: 'openid profile email'
};
```

### 5. Backend Token Exchange (for confidential clients)

```python
@router.post("/google/token")
async def google_token_exchange(request: GoogleTokenRequest):
    async with httpx.AsyncClient() as client:
        resp = await client.post(
            "https://oauth2.googleapis.com/token",
            data={
                "grant_type": "authorization_code",
                "code": request.code,
                "redirect_uri": request.redirect_uri,
                "client_id": GOOGLE_CLIENT_ID,
                "client_secret": GOOGLE_CLIENT_SECRET,  # Secret stays on server
                "code_verifier": request.code_verifier,
            },
        )
        tokens = resp.json()

        # Fetch user info
        userinfo = await client.get(
            "https://www.googleapis.com/oauth2/v3/userinfo",
            headers={"Authorization": f"Bearer {tokens['access_token']}"},
        )

        return {**tokens, "userinfo": userinfo.json()}
```

---

## Project Structure

```
auth-template/
├── backend/
│   ├── src/
│   │   ├── main.py              # FastAPI app
│   │   └── router/auth.py       # Token exchange endpoint
│   ├── Dockerfile
│   └── requirements.txt
├── frontend/
│   ├── src/
│   │   ├── lib/
│   │   │   ├── auth/
│   │   │   │   ├── auth.service.ts   # Login & callback handling
│   │   │   │   ├── oauth.ts          # Token exchange helpers
│   │   │   │   ├── pkce.ts           # PKCE utilities
│   │   │   │   └── providers/        # Provider configs
│   │   │   ├── stores/auth.store.ts  # Auth state management
│   │   │   └── types/auth.ts         # TypeScript types
│   │   └── routes/
│   │       ├── login/+page.svelte    # Login page
│   │       └── callback/             # OAuth callbacks
│   ├── Dockerfile
│   └── package.json
├── docker-compose.yml
└── .env.example
```

---

## Setup

1. **Clone and configure:**
   ```bash
   cp .env.example .env
   # Edit .env with your OAuth credentials
   ```

2. **Configure providers:**

   **Google:**
   - Create credentials at https://console.cloud.google.com/apis/credentials
   - Add redirect URI: `http://localhost:3000/callback/google`

   **Authentik:**
   - Create OAuth2 Provider in Authentik admin
   - Add redirect URI: `http://localhost:3000/callback/authentik`
   - Use public client (PKCE enabled)

3. **Run:**
   ```bash
   docker compose up
   ```

   Or locally:
   ```bash
   # Backend
   cd backend && pip install -r requirements.txt
   cd src && uvicorn main:app --reload --port 5000

   # Frontend
   cd frontend && npm install && npm run dev
   ```

4. **Open:** http://localhost:3000

---

## Security Checklist

- [x] Use PKCE for all OAuth flows
- [x] Validate `state` parameter to prevent CSRF
- [x] Store tokens securely (httpOnly cookies or secure storage)
- [x] Keep client secrets on backend only
- [x] Use HTTPS in production
- [x] Validate token signatures (for JWTs)
- [x] Implement token refresh before expiry

---

## Further Reading

- [OAuth 2.0 RFC 6749](https://tools.ietf.org/html/rfc6749)
- [PKCE RFC 7636](https://tools.ietf.org/html/rfc7636)
- [OpenID Connect](https://openid.net/connect/)
- [OAuth 2.0 Security Best Practices](https://tools.ietf.org/html/draft-ietf-oauth-security-topics)
